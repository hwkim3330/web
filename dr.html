<!DOCTYPE html>
<html lang="ko" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <title>V-DRIVE Web Console (Final Build)</title>
    <!-- 외부 라이브러리는 안정적인 CDN으로 로드 -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.min.css">
    <script src="https://cdn.jsdelivr.net/npm/cbor-x@1.5.8/dist/index.min.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/js-yaml@4.1.0/dist/js-yaml.min.js" defer></script>
    <style>
        :root { --font-family: -apple-system, system-ui, sans-serif; }
        body { padding: 1.5rem; max-width: 1200px; margin: auto; }
        pre { min-height: 40vh; max-height: 60vh; font-size: 0.85em; white-space: pre-wrap; word-break: break-all; }
        .grid-3 { display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem; align-items: end; }
        .hidden { display: none !important; }
        #btn-connect.disconnect { background-color: var(--pico-color-red-550); border-color: var(--pico-color-red-550); }
        details { margin-bottom: 1rem; background: var(--pico-card-background-color); border-radius: var(--pico-border-radius); padding: 1rem;}
    </style>
</head>
<body>
    <main class="container">
        <header>
            <hgroup>
                <h1>V-DRIVE Web Console</h1>
                <h2>The Ultimate "It Just Works" Edition.</h2>
            </hgroup>
        </header>

        <article>
            <button id="btn-connect" aria-busy="true">Initializing...</button>
        </article>

        <!-- 명령어 UI는 연결 성공 후 나타남 -->
        <section id="command-area" class="hidden">
            <details>
                <summary><strong>Interface Commands</strong></summary>
                <button type="button" class="cmd-btn" data-method="fetch" data-path="/ietf-interfaces:interfaces/interface" data-payload="[null]">Get All Interfaces</button>
                <footer>
                    <label>Name: <input type="text" id="if-name" value="12" style="width: 80px;"></label>
                    <label>Enabled: <select id="if-enabled" style="width: 120px;"><option value="true">true</option><option value="false">false</option></select></label>
                    <button type="button" id="btn-patch-if">Set Port State</button>
                </footer>
            </details>

            <details open>
                <summary><strong>PTP Commands</strong></summary>
                <div class="grid-3">
                    <label>Instance Index <input type="number" id="ptp-instance-idx" value="0"></label>
                    <label>Port Index <input type="number" id="ptp-port-idx" value="12"></label>
                    <label>Servo Index <input type="number" id="ptp-servo-idx" value="0"></label>
                </div>
                <div class="grid" style="grid-template-columns: 1fr 1fr; gap: 1rem;">
                    <button type="button" id="btn-set-ptp">Set PTP Instance (iPatch)</button>
                    <button type="button" id="btn-fetch-ptp" class="secondary">Fetch PTP Instance Status</button>
                </div>
            </details>

             <details>
                <summary><strong>System Commands</strong></summary>
                <button type="button" class="cmd-btn" data-method="post" data-path="/mchp-velocitysp-system:save-config" data-payload="null">Save Running Config</button>
            </details>
        </section>

        <pre><code id="log-output"></code></pre>
    </main>

<script>
// --- 1. SID 파일 목록 하드코딩 (직접 입력) ---
const SID_FILES = [
    "iana-crypt-hash@2014-08-06.sid", "iana-hardware@2018-03-13.sid", "iana-if-type@2017-01-19.sid", "ieee1588-ptp-dev@2024-04-12.sid", 
    "ieee1588-ptp@2022-08-30.sid", "ieee802-dot1ab-lldp-dev@2024-04-12.sid", "ieee802-dot1ab-lldp@2022-03-15.sid", 
    "ieee802-dot1ab-types@2022-03-15.sid", "ieee802-dot1as-ptp@2022-09-16.sid", "ieee802-dot1cb-stream-identification-dev@2025-06-30.sid", 
    "ieee802-dot1cb-stream-identification-types@2021-12-09.sid", "ieee802-dot1cb-stream-identification@2021-12-08.sid", 
    "ieee802-dot1q-bridge-dev@2024-04-12.sid", "ieee802-dot1q-bridge@2023-04-17.sid", "ieee802-dot1q-preemption-bridge@2022-08-18.sid", 
    "ieee802-dot1q-preemption@2022-08-18.sid", "ieee802-dot1q-psfp-bridge@2023-03-08.sid", "ieee802-dot1q-psfp@2023-03-16.sid", 
    "ieee802-dot1q-sched-bridge@2023-03-08.sid", "ieee802-dot1q-sched@2023-03-16.sid", "ieee802-dot1q-stream-filters-gates@2023-01-24.sid", 
    "ieee802-dot1q-types@2023-03-16.sid", "ieee802-ethernet-interface@2019-06-21.sid", "ieee802-types@2023-04-19.sid", 
    "ietf-constrained-yang-library-dev@2024-04-12.sid", "ietf-constrained-yang-library@2019-03-28.sid", "ietf-coreconf@2024-03-04.sid", 
    "ietf-datastores@2018-02-14.sid", "ietf-hardware-dev@2025-03-31.sid", "ietf-hardware@2018-03-13.sid", "ietf-inet-types@2013-07-15.sid", 
    "ietf-interfaces-dev@2024-04-12.sid", "ietf-interfaces@2018-02-20.sid", "ietf-ip@2018-02-22.sid", "ietf-ipv4-unicast-routing@2018-03-13.sid", 
    "ietf-netconf-acm-dev@2024-04-12.sid", "ietf-netconf-acm@2018-02-14.sid", "ietf-restconf@2017-01-26.sid", 
    "ietf-routing-dev@2024-04-12.sid", "ietf-routing@2018-03-13.sid", "ietf-sid-file@2023-10-27.sid", 
    "ietf-system-dev@2024-04-12.sid", "ietf-system@2014-08-06.sid", "ietf-yang-structure-ext@2020-06-17.sid", 
    "ietf-yang-types@2013-07-15.sid", "mchp-velocitysp-acl@2025-06-30.sid", "mchp-velocitysp-aggr@2025-06-30.sid", 
    "mchp-velocitysp-bridge@2025-06-30.sid", "mchp-velocitysp-dhcp@2023-02-23.sid", "mchp-velocitysp-ip@2023-10-04.sid", 
    "mchp-velocitysp-port@2025-06-30.sid", "mchp-velocitysp-ptp@2025-06-25.sid", "mchp-velocitysp-redbox@2025-06-30.sid", 
    "mchp-velocitysp-system@2025-06-30.sid"
];

// --- 2. 전역 변수 및 초기화 ---
const YANG_CATALOG_PATH = './yang-catalog/';
let YANG_DICTIONARY = {};
let port, writer, reader;

(async function initialize() {
    log('Initializing Console...');
    try {
        const promises = SID_FILES.map(filename =>
            fetch(`${YANG_CATALOG_PATH}${filename}`).then(res => {
                if (!res.ok) throw new Error(`Failed to load ${filename}`);
                return res.text();
            })
        );
        const contents = await Promise.all(promises);
        contents.forEach(parseSidContent);
        
        const connectBtn = document.getElementById('btn-connect');
        connectBtn.disabled = false;
        connectBtn.ariaBusy = false;
        connectBtn.textContent = 'Connect to Device';
        log(`✅ Console is ready. ${Object.keys(YANG_DICTIONARY).length} SIDs loaded.`);
    } catch (err) {
        log(`❌ Initialization failed: ${err.message}`);
        const connectBtn = document.getElementById('btn-connect');
        connectBtn.ariaBusy = false;
        connectBtn.textContent = 'Init Failed';
    }
})();

function parseSidContent(content) {
    content.split('\n').forEach(line => {
        if (line.startsWith('#') || line.trim() === '') return;
        const [sidStr, , nameStr] = line.split(',');
        if (sidStr && nameStr) {
            const sid = parseInt(sidStr.trim(), 10);
            const name = nameStr.trim().replace(/"/g, '');
            if (!isNaN(sid) && name) YANG_DICTIONARY[name] = sid;
        }
    });
}

// --- 3. 핵심 로직: 재귀적 CBOR 인코더 (수정됨) ---
function jsToCbor(jsObject) {
    if (typeof jsObject !== 'object' || jsObject === null) return jsObject;
    if (Array.isArray(jsObject)) return jsObject.map(item => jsToCbor(item));

    const cborMap = new Map();
    for (const key in jsObject) {
        // 네임스페이스(e.g., mchp-velocitysp-ptp:)를 제거하고 SID를 찾음
        const sidKey = key.includes(':') ? key.split(':')[1] : key;
        const sid = YANG_DICTIONARY[sidKey];
        if (sid === undefined) throw new Error(`SID for key '${sidKey}' not found.`);
        cborMap.set(sid, jsToCbor(jsObject[key]));
    }
    return cborMap;
}

function createCoreconfPayload(path, payloadData) {
    if (Object.keys(YANG_DICTIONARY).length === 0) throw new Error("Dictionary not ready.");

    let currentPayload = jsToCbor(payloadData);
    
    // 경로 파싱: 키 필터링을 위한 정규식
    const predicates = [];
    path = path.replace(/\[([^=]+)='([^']+)'\]/g, (match, key, value) => {
        predicates.push({ key, value });
        return ''; // 경로에서 필터 부분 제거
    });

    const pathSegments = path.replace(/^\//, '').split(/\/|:/);

    // 경로를 SID 태그로 감싸기 (거꾸로)
    for (let i = pathSegments.length - 1; i >= 0; i--) {
        const segment = pathSegments[i];
        if (!segment) continue;

        const sid = YANG_DICTIONARY[segment];
        if (sid === undefined) throw new Error(`SID for path segment '${segment}' not found.`);
        
        // 필터가 있는 경우, 필터 정보를 페이로드에 추가
        if (i === pathSegments.length - 1 && predicates.length > 0) {
            const filter = predicates.pop(); // 가장 안쪽 필터부터 처리
            const keySid = YANG_DICTIONARY[filter.key];
            if (keySid === undefined) throw new Error(`SID for filter key '${filter.key}' not found.`);
            
            // 페이로드가 배열이 아니면 배열로 만듦 (ipatch 등)
            if (!Array.isArray(currentPayload)) currentPayload = [currentPayload];
            // 필터 키와 값을 첫번째 아이템에 추가
            if (currentPayload.length > 0 && currentPayload[0] instanceof Map) {
                currentPayload[0].set(keySid, isNaN(parseInt(filter.value)) ? filter.value : parseInt(filter.value));
            }
        }
        currentPayload = new CBOR.CborTag(sid, currentPayload);
    }
    
    return CBOR.encode(currentPayload);
}

// --- 4. MUP1 전송 및 Web Serial 통신 ---
async function sendMup1Command(method, path, payloadData) {
    if (!writer) return;
    try {
        const commandChar = method.charAt(0);
        log(`[TX] Method: ${method}, Path: ${path}`);
        const cborPayload = createCoreconfPayload(path, payloadData);
        
        const frameHeader = new TextEncoder().encode(`>${commandChar}<`);
        const finalFrame = new Uint8Array(frameHeader.length + cborPayload.length);
        finalFrame.set(frameHeader);
        finalFrame.set(cborPayload, frameHeader.length);
        
        log(`[TX-HEX] ${Array.from(finalFrame).map(b => b.toString(16).padStart(2, '0')).join(' ')}`);
        await writer.write(finalFrame);
    } catch (err) {
        log(`❌ Command Error: ${err.message}`);
    }
}

async function connect() {
    const connectButton = document.getElementById('btn-connect');
    if (port) {
        await disconnect();
        return;
    }
    try {
        port = await navigator.serial.requestPort();
        await port.open({ baudRate: 115200 });
        writer = port.writable.getWriter();
        reader = port.readable.getReader();
        
        connectButton.textContent = 'Disconnect';
        connectButton.classList.add('disconnect');
        document.getElementById('command-area').classList.remove('hidden');
        log('✅ Device connected.');
        listenForData();
    } catch (err) {
        if (err.name !== 'AbortError') log(`❌ Connection failed: ${err.message}`);
    }
}

async function disconnect() {
    const connectButton = document.getElementById('btn-connect');
    if (reader) { await reader.cancel().catch(() => {}); reader = null; }
    if (writer) { await writer.close().catch(() => {}); writer = null; }
    if (port) { await port.close().catch(() => {}); port = null; }
    
    connectButton.textContent = 'Connect to Device';
    connectButton.classList.remove('disconnect');
    document.getElementById('command-area').classList.add('hidden');
    log('🔌 Device disconnected.');
}

async function listenForData() {
    let buffer = new Uint8Array();
    while (port?.readable) {
        try {
            const { value, done } = await reader.read();
            if (done) break;

            const newBuffer = new Uint8Array(buffer.length + value.length);
            newBuffer.set(buffer);
            newBuffer.set(value, buffer.length);
            buffer = newBuffer;

            // MUP1 응답은 명확한 구분자가 없을 수 있음.
            // 일단 텍스트로 변환 시도, YAML 형식이 보이면 처리
            const textResponse = new TextDecoder().decode(buffer, {stream: true});
            const yamlStartIndex = textResponse.indexOf('---');
            if (yamlStartIndex !== -1) {
                try {
                    const parsed = jsyaml.load(textResponse);
                    log(`[RX]\n${jsyaml.dump(parsed, { indent: 2 })}`);
                    buffer = new Uint8Array(); // 성공적으로 파싱했으면 버퍼 비우기
                } catch(e) {
                    // 아직 YAML이 완성되지 않았을 수 있음
                }
            }
        } catch (error) {
            if (!error.message.includes("The device has been lost")) log(`❌ Read loop error: ${error.message}`);
            await disconnect();
            break;
        }
    }
}

// --- 5. UI 이벤트 핸들러 및 초기화 ---
function log(message) {
    const logEl = document.getElementById('log-output');
    logEl.textContent += `${new Date().toLocaleTimeString()}: ${message}\n\n`;
    logEl.scrollTop = logEl.scrollHeight;
}

document.addEventListener('DOMContentLoaded', () => {
    document.getElementById('btn-connect').addEventListener('click', connect);

    document.querySelectorAll('.cmd-btn').forEach(button => {
        button.addEventListener('click', (e) => {
            const { method, path, payload } = e.target.dataset;
            sendMup1Command(method, path, JSON.parse(payload));
        });
    });

    document.getElementById('btn-patch-if').addEventListener('click', () => {
        const name = document.getElementById('if-name').value;
        const enabled = document.getElementById('if-enabled').value === 'true';
        if (!name) return alert('Interface Name is required.');
        const path = "/ietf-interfaces:interfaces/interface";
        const payload = [{ name, enabled }];
        sendMup1Command('ipatch', path, payload);
    });

    document.getElementById('btn-set-ptp').addEventListener('click', () => {
        const instanceIndex = parseInt(document.getElementById('ptp-instance-idx').value, 10);
        const portIndex = parseInt(document.getElementById('ptp-port-idx').value, 10);
        const servoIndex = parseInt(document.getElementById('ptp-servo-idx').value, 10);

        const path = `/ieee1588-ptp:ptp/instances/instance[instance-index='${instanceIndex}']`;
        const payload = {
            "ports": { "port": [{ "port-index": portIndex }] },
            "mchp-velocitysp-ptp:servos": { "servo": [{
                "servo-index": servoIndex, "servo-type": "pi", "ltc-index": 0
            }]}
        };
        sendMup1Command('ipatch', path, payload);
    });

    document.getElementById('btn-fetch-ptp').addEventListener('click', () => {
        const instanceIndex = document.getElementById('ptp-instance-idx').value;
        const path = `/ieee1588-ptp:ptp/instances/instance[instance-index='${instanceIndex}']`;
        sendMup1Command('fetch', path, null);
    });
});
</script>
</body>
</html>
